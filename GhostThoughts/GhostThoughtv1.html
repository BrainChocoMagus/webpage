<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ghost Thoughts</title>
  <link href="/ghost-style.css" rel="stylesheet" type="text/css" media="all">
  
  <!-- Load Supabase from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <div class="header">
    <h1>Ghost Thoughts</h1>
    <p class="subtitle">Your thoughts float around like ghosts with different moods</p>
  </div>

  <div class="container">
    <div class="instructions">
      <p>These ghosts represent your saved thoughts, each with a different mood. Hover over a ghost to see the thought, and click to keep it visible.</p>
    </div>

    <div class="button-group">
      <button class="addBtn" id="addThoughtBtn">+</button>
      <button class="spawnBtn" id="spawnThoughtBtn">üëª</button>
      <button class="clearBtn" id="clearThoughtsBtn">üóëÔ∏è</button>
    </div>

    <div id="thoughtForm" class="thought-form">
      <h3>Add a Thought</h3>
      <input type="text" id="thoughtTitle" placeholder="Title (optional)">

      <div class="html-toggle">
        <input type="checkbox" id="htmlToggle">
        <label for="htmlToggle">Create extended post with HTML</label>
      </div>

      <div id="simpleText">
        <textarea id="thoughtText" placeholder="What's on your mind?"></textarea>
      </div>

      <div id="htmlEditor" class="html-editor">
        <textarea id="htmlContent" placeholder="Write your HTML content here..."></textarea>
      </div>

      <label class="mood-label">Select Mood:</label>
      <select id="moodSelect">
        <option value="joy">Joy üòä</option>
        <option value="sadness">Sadness üò¢</option>
        <option value="anger">Anger üò†</option>
        <option value="fear">Fear üò®</option>
        <option value="disgust">Disgust üòí</option>
        <option value="inlove">In Love üòç</option>
        <option value="other">Other Mood</option>
      </select>

      <div id="customMood" class="custom-mood">
        <input type="text" id="customMoodName" placeholder="Mood name (optional)">
        <input type="text" id="customMoodEmoji" placeholder="Emoji (optional, e.g., üòé)">
      </div>

      <div class="form-controls">
        <button id="cancelBtn">Cancel</button>
        <button id="submitBtn">Save Thought</button>
      </div>
    </div>

    <div id="message" class="message">
      <p>No thoughts yet. Add your own using the + button.</p>
    </div>
  </div>

  <!-- Blog Overlay -->
  <div id="blogOverlay" class="blog-overlay">
    <div class="blog-content">
      <div class="blog-close" id="blogClose">X</div>
      <div class="blog-header">
        <div id="blogGhost" class="blog-ghost">
          <div class="ghost-body"></div>
          <div class="ghost-eyes"><div class="ghost-eye"></div><div class="ghost-eye"></div></div>
          <div class="ghost-mouth"></div>
          <div class="ghost-skirt"><div class="ghost-fold"></div><div class="ghost-fold"></div><div class="ghost-fold"></div></div>
          <div class="heart"></div>
        </div>
        <div>
          <h2 id="blogMood" class="blog-mood"></h2>
          <div id="blogDate" class="blog-date"></div>
        </div>
      </div>
      <h2 id="blogTitle" class="blog-title"></h2>
      <div id="blogText" class="blog-text"></div>
      <div id="blogHtml" class="blog-html-content"></div>
    </div>
  </div>

  <footer>
    <p>Hover over ghosts to see thoughts. Click to view full post.</p>
  </footer>

  <script>
    // ==================== SUPABASE SETUP & CONFIGURATION ====================
    
    // Initialize Supabase with your project credentials
    // Replace these with your actual Supabase project URL and API key
    const SUPABASE_URL = "https://mfkrkhmvqythkalsfkcm.supabase.co";
    const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1ma3JraG12cXl0aGthbHNma2NtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU4MjU5MjYsImV4cCI6MjA3MTQwMTkyNn0.OYjwJrb2YHSMEo4bdtjz9A2mopDzSjeH8jq9HTxtmuU";
    
    // Create Supabase client
    const supabase = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    
    // ==================== GLOBAL VARIABLES ====================
    
    // Maximum number of ghosts allowed on screen
    const maxGhosts = 20;
    
    // Radius within which ghosts will react to mouse movement
    const evasionRadius = 150;
    
    // Map to store positions of all ghosts for collision detection
    const ghostPositions = new Map();
    
    // Set to track which sample thoughts have been used
    const sampleThoughtsUsed = new Set();
    
    // ==================== SUPABASE CRUD OPERATIONS ====================
    
    /**
     * Saves a thought to the Supabase database
     * @param {Object} thought - The thought object to save
     * @returns {Promise<boolean>} - True if successful, false otherwise
     */
    async function saveThought(thought) {
      try {
        // Insert the thought into the 'thoughts' table
        const { data, error } = await supabase
          .from('thoughts')
          .insert([thought])
          .select(); // Return the inserted data
          
        if (error) {
          console.error('Error saving thought to Supabase:', error);
          alert('Error saving thought: ' + error.message);
          return false;
        }
        
        console.log('Thought saved successfully:', data);
        return true;
      } catch (err) {
        console.error('Unexpected error saving thought:', err);
        return false;
      }
    }
    
    /**
     * Loads all thoughts from the Supabase database
     * @returns {Promise<Array>} - Array of thought objects
     */
    async function loadThoughts() {
      try {
        // Select all thoughts, ordered by creation date (newest first)
        const { data, error } = await supabase
          .from('thoughts')
          .select('*')
          .order('created_at', { ascending: false });
          
        if (error) {
          console.error('Error loading thoughts from Supabase:', error);
          return [];
        }
        
        console.log('Thoughts loaded successfully:', data);
        return data || [];
      } catch (err) {
        console.error('Unexpected error loading thoughts:', err);
        return [];
      }
    }
    
    /**
     * Clears all thoughts from the Supabase database
     * @returns {Promise<boolean>} - True if successful, false otherwise
     */
    async function clearThoughts() {
      try {
        // Delete all thoughts from the 'thoughts' table
        const { error } = await supabase
          .from('thoughts')
          .delete()
          .neq('id', 0); // Delete all records (neq = not equal)
          
        if (error) {
          console.error('Error clearing thoughts from Supabase:', error);
          alert('Error clearing thoughts: ' + error.message);
          return false;
        }
        
        console.log('Thoughts cleared successfully');
        return true;
      } catch (err) {
        console.error('Unexpected error clearing thoughts:', err);
        return false;
      }
    }
    
    /**
     * Sets up real-time subscription to thought changes
     * This enables synchronization across devices
     */
    function setupRealtimeSubscription() {
      // Subscribe to INSERT events (new thoughts added)
      supabase
        .channel('thoughts-changes')
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'thoughts'
          },
          (payload) => {
            console.log('New thought received from another device:', payload);
            // Create a ghost for the new thought
            createGhostFromPayload(payload.new);
          }
        )
        .on(
          'postgres_changes',
          {
            event: 'DELETE',
            schema: 'public',
            table: 'thoughts'
          },
          (payload) => {
            console.log('Thought deleted from another device:', payload);
            // Remove all ghosts (simplified approach)
            document.querySelectorAll('.ghost-container').forEach(el => el.remove());
            ghostPositions.clear();
            // Reload thoughts to reflect current state
            loadGhosts();
          }
        )
        .subscribe();
    }
    
    /**
     * Creates a ghost from a real-time payload
     * @param {Object} payload - The payload from Supabase real-time
     */
    function createGhostFromPayload(payload) {
      createGhost({
        id: payload.id,
        title: payload.title,
        text: payload.text,
        htmlContent: payload.html_content,
        mood: payload.mood,
        customMood: payload.custom_mood,
        date: new Date(payload.created_at).toLocaleDateString()
      });
    }

    // ==================== DOM ELEMENTS ====================
    
    // Buttons
    const addThoughtBtn = document.getElementById('addThoughtBtn');
    const spawnThoughtBtn = document.getElementById('spawnThoughtBtn');
    const clearThoughtsBtn = document.getElementById('clearThoughtsBtn');
    
    // Form elements
    const thoughtForm = document.getElementById('thoughtForm');
    const cancelBtn = document.getElementById('cancelBtn');
    const submitBtn = document.getElementById('submitBtn');
    const moodSelect = document.getElementById('moodSelect');
    const customMood = document.getElementById('customMood');
    const customMoodName = document.getElementById('customMoodName');
    const customMoodEmoji = document.getElementById('customMoodEmoji');
    const htmlToggle = document.getElementById('htmlToggle');
    const simpleText = document.getElementById('simpleText');
    const htmlEditor = document.getElementById('htmlEditor');
    const thoughtText = document.getElementById('thoughtText');
    const htmlContent = document.getElementById('htmlContent');
    const thoughtTitle = document.getElementById('thoughtTitle');
    
    // Blog overlay elements
    const blogOverlay = document.getElementById('blogOverlay');
    const blogClose = document.getElementById('blogClose');
    const blogGhost = document.getElementById('blogGhost');
    const blogMood = document.getElementById('blogMood');
    const blogDate = document.getElementById('blogDate');
    const blogTitle = document.getElementById('blogTitle');
    const blogText = document.getElementById('blogText');
    const blogHtml = document.getElementById('blogHtml');
    
    // Message element
    const message = document.getElementById('message');

    // ==================== EVENT LISTENERS ====================
    
    // Toggle HTML editor
    htmlToggle.addEventListener('change', () => {
      if (htmlToggle.checked) {
        simpleText.style.display = 'none';
        htmlEditor.classList.add('show');
      } else {
        simpleText.style.display = 'block';
        htmlEditor.classList.remove('show');
      }
    });
    
    // Show/hide thought form
    addThoughtBtn.addEventListener('click', () => {
      thoughtForm.classList.toggle('show');
      message.classList.remove('show');
    });
    
    // Show custom mood fields when "other" is selected
    moodSelect.addEventListener('change', () => {
      if (moodSelect.value === 'other') {
        customMood.classList.add('show');
      } else {
        customMood.classList.remove('show');
      }
    });
    
    // Cancel form
    cancelBtn.addEventListener('click', closeForm);
    
    // Clear all thoughts
    clearThoughtsBtn.addEventListener('click', async () => {
      const confirmed = confirm("Are you sure you want to delete all thoughts? This cannot be undone.");
      if (!confirmed) return;
      
      const success = await clearThoughts();
      if (success) {
        document.querySelectorAll('.ghost-container').forEach(el => el.remove());
        ghostPositions.clear();
        sampleThoughtsUsed.clear();
        message.classList.add('show');
      }
    });
    
    // Spawn a random thought
    spawnThoughtBtn.addEventListener('click', async () => {
      const saved = await loadThoughts();
      
      if (saved && saved.length > 0) {
        const randomThought = saved[Math.floor(Math.random() * saved.length)];
        createGhost(randomThought);
        return;
      }
      
      // Fallback to sample thoughts if no saved thoughts
      const sampleThoughts = [
        { title: "Happy Day", text: "I'm so happy I could float forever!", mood: "joy", date: new Date().toLocaleDateString() },
        { title: "Feeling Blue", text: "Sometimes I feel blue for no reason", mood: "sadness", date: new Date().toLocaleDateString() },
        { title: "Angry Moment", text: "That really makes me mad!", mood: "anger", date: new Date().toLocaleDateString() },
        { title: "Scared Thoughts", text: "I'm scared of what might happen tomorrow", mood: "fear", date: new Date().toLocaleDateString() },
        { title: "Disgusting!", text: "Eww, that's disgusting!", mood: "disgust", date: new Date().toLocaleDateString() },
        { title: "In Love", text: "My heart beats for you, even though I don't have one!", mood: "inlove", date: new Date().toLocaleDateString() }
      ];
      
      const available = sampleThoughts.filter(t => !sampleThoughtsUsed.has(t.text));
      if (available.length > 0) {
        const randomThought = available[Math.floor(Math.random() * available.length)];
        sampleThoughtsUsed.add(randomThought.text);
        createGhost(randomThought);
        if (sampleThoughtsUsed.size >= sampleThoughts.length) {
          message.classList.add('show');
        }
      } else {
        message.classList.add('show');
      }
    });
    
    // Submit form
    submitBtn.addEventListener('click', handleFormSubmit);
    
    // Close blog overlay
    blogClose.addEventListener('click', () => {
      blogOverlay.classList.remove('active');
    });
    
    // Close blog overlay when clicking outside content
    blogOverlay.addEventListener('click', (e) => {
      if (e.target === blogOverlay) {
        blogOverlay.classList.remove('active');
      }
    });

    // ==================== FORM HANDLING ====================
    
    /**
     * Handles form submission
     */
    async function handleFormSubmit() {
      const text = thoughtText.value.trim();
      const html = htmlContent.value.trim();
      const title = thoughtTitle.value.trim();
      let mood = moodSelect.value;
      let customMoodData = null;
      
      // Validate form
      if (!text && !html) {
        alert("Please enter some text or HTML content");
        return;
      }
      
      // Handle custom mood
      if (mood === 'other') {
        const customName = customMoodName.value.trim();
        const customEmoji = customEmojiInput.value.trim();
        if (customName || customEmoji) {
          customMoodData = { 
            name: customName || "Mystery Mood", 
            emoji: customEmoji || "ü§î" 
          };
        }
      }
      
      // Prepare thought data for database
      const thoughtData = {
        title: title || null,
        text: text || "HTML Content",
        html_content: htmlToggle.checked ? html : null,
        mood: mood,
        custom_mood: customMoodData,
        created_at: new Date().toISOString()
      };
      
      // Save to Supabase
      const success = await saveThought(thoughtData);
      
      if (!success) return;
      
      // Create ghost with the new thought
      createGhost({
        title: title || null,
        text: text || "HTML Content",
        htmlContent: htmlToggle.checked ? html : null,
        mood: mood,
        customMood: customMoodData,
        date: new Date().toLocaleDateString()
      });
      
      // Reset form
      closeForm();
    }
    
    /**
     * Closes the form and resets all fields
     */
    function closeForm() {
      thoughtForm.classList.remove('show');
      customMood.classList.remove('show');
      moodSelect.value = 'joy';
      customMoodName.value = '';
      customMoodEmoji.value = '';
      htmlToggle.checked = false;
      simpleText.style.display = 'block';
      htmlEditor.classList.remove('show');
      thoughtText.value = '';
      htmlContent.value = '';
      thoughtTitle.value = '';
    }

    // ==================== GHOST MANAGEMENT ====================
    
    /**
     * Loads all ghosts from the database on page load
     */
    async function loadGhosts() {
      // Clear existing ghosts
      document.querySelectorAll('.ghost-container').forEach(el => el.remove());
      ghostPositions.clear();
      
      // Load thoughts from Supabase
      const saved = await loadThoughts();
      
      if (saved && saved.length > 0) {
        // Create a ghost for each thought
        saved.forEach(thought => {
          createGhost({
            id: thought.id,
            title: thought.title,
            text: thought.text,
            htmlContent: thought.html_content,
            mood: thought.mood,
            customMood: thought.custom_mood,
            date: new Date(thought.created_at).toLocaleDateString()
          });
        });
      } else {
        // Create sample ghosts if no thoughts exist
        const sampleThoughts = [
          { title: "Happy Day", text: "I'm so happy I could float forever!", mood: "joy", date: new Date().toLocaleDateString() },
          { title: "Feeling Blue", text: "Sometimes I feel blue for no reason", mood: "sadness", date: new Date().toLocaleDateString() }
        ];
        sampleThoughts.forEach(t => createGhost(t));
      }
    }
    
    /**
     * Creates a ghost with the given thought
     * @param {Object} thought - The thought to display
     * @param {number} x - Optional x coordinate
     * @param {number} y - Optional y coordinate
     */
    function createGhost(thought, x = null, y = null) {
      // Create ghost container
      const ghostContainer = document.createElement('div');
      ghostContainer.className = 'ghost-container';
      
      // Create ghost element
      const ghost = document.createElement('div');
      ghost.className = `ghost ${thought.mood}`;
      
      // Create ghost body
      const ghostBody = document.createElement('div');
      ghostBody.className = 'ghost-body';
      
      // Create ghost eyes
      const ghostEyes = document.createElement('div');
      ghostEyes.className = 'ghost-eyes';
      
      const leftEye = document.createElement('div');
      leftEye.className = 'ghost-eye';
      
      const rightEye = document.createElement('div');
      rightEye.className = 'ghost-eye';
      
      // Create ghost mouth
      const mouth = document.createElement('div');
      mouth.className = 'ghost-mouth';
      
      // Create ghost skirt
      const skirt = document.createElement('div');
      skirt.className = 'ghost-skirt';
      
      // Create heart for inlove ghost
      const heart = document.createElement('div');
      heart.className = 'heart';
      
      // Create 3 folds for the skirt
      for (let i = 0; i < 3; i++) {
        const fold = document.createElement('div');
        fold.className = 'ghost-fold';
        skirt.appendChild(fold);
      }
      
      // Assemble the ghost
      ghostEyes.appendChild(leftEye);
      ghostEyes.appendChild(rightEye);
      ghost.appendChild(ghostBody);
      ghost.appendChild(ghostEyes);
      ghost.appendChild(mouth);
      ghost.appendChild(skirt);
      ghost.appendChild(heart);
      
      // Create speech balloon
      const balloon = document.createElement('div');
      balloon.className = 'balloon';
      
      // Display custom mood name if it's an "other" mood
      let moodDisplay = thought.mood;
      if (thought.mood === 'other') {
        if (thought.customMood && thought.customMood.name) {
          moodDisplay = thought.customMood.name;
        } else {
          moodDisplay = "Mystery Mood";
        }
      }
      
      // Add emoji if available
      let emojiDisplay = "";
      if (thought.mood === 'other' && thought.customMood && thought.customMood.emoji) {
        emojiDisplay = " " + thought.customMood.emoji;
      }
      
      // Show title or preview text in balloon
      let previewText = thought.title || "";
      
      if (!previewText && thought.htmlContent) {
        previewText = "Click to view full post...";
      } else if (!previewText) {
        // Show first line of text if no title
        const firstLineEnd = thought.text.indexOf('\n');
        if (firstLineEnd !== -1) {
          previewText = thought.text.substring(0, firstLineEnd);
          if (previewText.length > 80) {
            previewText = previewText.substring(0, 80) + "...";
          }
        } else if (thought.text.length > 80) {
          previewText = thought.text.substring(0, 80) + "...";
        } else {
          previewText = thought.text;
        }
      }
      
      balloon.innerHTML = `<strong>${moodDisplay.toUpperCase()}${emojiDisplay}</strong><br>${previewText}<br><small>${thought.date}</small>`;
      ghostContainer.appendChild(balloon);
      ghostContainer.appendChild(ghost);
      
      // Add class for long content
      if ((thought.text && thought.text.length > 80) || thought.htmlContent || thought.title) {
        balloon.classList.add('long');
      }
      
      // Position the ghost
      if (x !== null && y !== null) {
        ghostContainer.style.left = x + 'px';
        ghostContainer.style.top = y + 'px';
      } else {
        positionGhost(ghostContainer);
      }
      
      document.body.appendChild(ghostContainer);
      
      // Store the position for this ghost
      const ghostId = thought.id || Date.now() + Math.random().toString(36).substr(2, 9);
      ghostContainer.dataset.ghostId = ghostId;
      ghostContainer.dataset.thought = JSON.stringify(thought);
      ghostPositions.set(ghostId, {
        x: parseFloat(ghostContainer.style.left),
        y: parseFloat(ghostContainer.style.top)
      });
      
      // Set mood-specific properties
      setMoodProperties(ghost, thought.mood);
      
      // Hover to show balloon
      ghostContainer.addEventListener('mouseenter', () => {
        document.querySelectorAll('.balloon').forEach(b => b.classList.remove('show'));
        balloon.classList.add('show');
      });
      
      ghostContainer.addEventListener('mouseleave', () => {
        balloon.classList.remove('show');
      });
      
      // Click to show full blog view
      ghostContainer.addEventListener('click', (e) => {
        e.stopPropagation();
        const thoughtData = JSON.parse(ghostContainer.dataset.thought);
        showBlogView(thoughtData);
      });
      
      // Mouse movement with mood-specific behavior
      document.addEventListener('mousemove', (e) => {
        const ghostRect = ghostContainer.getBoundingClientRect();
        const ghostCenterX = ghostRect.left + ghostRect.width / 2;
        const ghostCenterY = ghostRect.top + ghostRect.height / 2;
        
        const distance = Math.sqrt(
          Math.pow(e.clientX - ghostCenterX, 2) + 
          Math.pow(e.clientY - ghostCenterY, 2)
        );
        
        if (distance < evasionRadius) {
          // Calculate direction based on mood
          let dx = (ghostCenterX - e.clientX);
          let dy = (ghostCenterY - e.clientY);
          
          // Normalize and apply mood-specific multipliers
          const norm = Math.sqrt(dx * dx + dy * dy);
          dx /= norm;
          dy /= norm;
          
          // Apply mood-specific behavior
          applyMoodBehavior(ghostContainer, dx, dy, thought.mood, e);
        }
      });
      
      // Start floating animation
      moveGhost(ghostContainer, thought.mood);
    }
    
    /**
     * Positions a ghost in an available space
     * @param {HTMLElement} ghostContainer - The ghost element to position
     */
    function positionGhost(ghostContainer) {
      const ghostWidth = 60;
      const ghostHeight = 80;
      const padding = 20;
      
      // Try to find a position that doesn't overlap with existing ghosts
      let attempts = 0;
      let placed = false;
      
      while (!placed && attempts < 50) {
        const x = padding + Math.random() * (window.innerWidth - ghostWidth - padding * 2);
        const y = padding + Math.random() * (window.innerHeight - ghostHeight - padding * 2 - 100);
        
        // Check if this position overlaps with existing ghosts
        const overlapping = Array.from(document.querySelectorAll('.ghost-container')).some(existingGhost => {
          const rect = existingGhost.getBoundingClientRect();
          return !(x > rect.right + padding || x + ghostWidth < rect.left - padding ||
                  y > rect.bottom + padding || y + ghostHeight < rect.top - padding);
        });
        
        if (!overlapping) {
          ghostContainer.style.left = x + 'px';
          ghostContainer.style.top = y + 'px';
          placed = true;
        }
        
        attempts++;
      }
      
      // If we couldn't find a non-overlapping position, place it randomly
      if (!placed) {
        ghostContainer.style.left = Math.random() * (window.innerWidth - 100) + 'px';
        ghostContainer.style.top = (50 + Math.random() * (window.innerHeight - 200)) + 'px';
      }
    }
    
    /**
     * Sets visual properties based on mood
     * @param {HTMLElement} ghost - The ghost element
     * @param {string} mood - The mood to apply
     */
    function setMoodProperties(ghost, mood) {
      // For "other" moods, randomly assign properties from existing moods
      const actualMood = mood === 'other' ? getRandomMood() : mood;
      
      switch(actualMood) {
        case 'joy':
          ghost.style.transform = 'scale(1.1)';
          ghost.style.filter = 'brightness(1.2)';
          break;
        case 'sadness':
          ghost.style.opacity = '0.8';
          break;
        case 'anger':
          ghost.querySelector('.ghost-mouth').style.backgroundColor = 'red';
          break;
        case 'fear':
          ghost.style.transition = 'all 0.3s';
          setInterval(() => {
            ghost.style.transform = `translateX(${Math.random() > 0.5 ? 1 : -1}px)`;
          }, 300);
          break;
        case 'disgust':
          ghost.style.opacity = '0.9';
          break;
        case 'inlove':
          const eyes = ghost.querySelectorAll('.ghost-eye');
          eyes.forEach(eye => {
            eye.style.borderRadius = '0';
            eye.style.transform = 'rotate(45deg)';
            eye.style.width = '6px';
            eye.style.height = '6px';
          });
          break;
      }
    }
    
    /**
     * Gets a random mood for "other" mood types
     * @returns {string} - A random mood
     */
    function getRandomMood() {
      const moods = ['joy', 'sadness', 'anger', 'fear', 'disgust', 'inlove'];
      return moods[Math.floor(Math.random() * moods.length)];
    }
    
    /**
     * Applies mood-specific behavior to a ghost
     * @param {HTMLElement} ghostContainer - The ghost element
     * @param {number} dx - X direction
     * @param {number} dy - Y direction
     * @param {string} mood - The mood to apply
     * @param {Event} mouseEvent - The mouse event
     */
    function applyMoodBehavior(ghostContainer, dx, dy, mood, mouseEvent) {
      // For "other" moods, randomly assign behavior from existing moods
      const actualMood = mood === 'other' ? getRandomMood() : mood;
      
      const behaviorStrength = 0.8;
      
      // Mood-specific behavior multipliers
      let speedMultiplier = 1;
      let jitterX = 0;
      let jitterY = 0;
      
      switch(actualMood) {
        case 'joy':
          speedMultiplier = 0.8;
          jitterX = (Math.random() - 0.5) * 0.3;
          jitterY = (Math.random() - 0.5) * 0.3;
          break;
        case 'sadness':
          speedMultiplier = 0.5;
          break;
        case 'anger':
          speedMultiplier = 1.0;
          jitterX = (Math.random() - 0.5) * 1;
          jitterY = (Math.random() - 0.5) * 1;
          break;
        case 'fear':
          speedMultiplier = 1.2;
          jitterX = (Math.random() - 0.5) * 1.5;
          jitterY = (Math.random() - 0.5) * 1.5;
          break;
        case 'disgust':
          speedMultiplier = 0.4;
          break;
        case 'inlove':
          speedMultiplier = -1.2;
          jitterX = (Math.random() - 0.5) * 0.5;
          jitterY = (Math.random() - 0.5) * 0.5;
          
          const ghostRect = ghostContainer.getBoundingClientRect();
          const ghostCenterX = ghostRect.left + ghostRect.width / 2;
          const ghostCenterY = ghostRect.top + ghostRect.height / 2;
          
          const towardX = (mouseEvent.clientX - ghostCenterX) * 0.02;
          const towardY = (mouseEvent.clientY - ghostCenterY) * 0.02;
          
          jitterX += towardX;
          jitterY += towardY;
          break;
      }
      
      // Calculate new position with mood-specific behavior
      const currentX = parseFloat(ghostContainer.style.left || 0);
      const currentY = parseFloat(ghostContainer.style.top || 0);
      
      const newX = currentX + (dx * behaviorStrength * speedMultiplier) + jitterX;
      const newY = currentY + (dy * behaviorStrength * speedMultiplier) + jitterY;
      
      // Keep within bounds
      const boundedX = Math.max(0, Math.min(window.innerWidth - 100, newX));
      const boundedY = Math.max(0, Math.min(window.innerHeight - 150, newY));
      
      ghostContainer.style.left = boundedX + 'px';
      ghostContainer.style.top = boundedY + 'px';
      
      // Update stored position
      const ghostId = ghostContainer.dataset.ghostId;
      if (ghostId && ghostPositions.has(ghostId)) {
        ghostPositions.set(ghostId, { x: boundedX, y: boundedY });
      }
    }
    
    /**
     * Makes the ghost float with mood-specific movement
     * @param {HTMLElement} ghostContainer - The ghost element
     * @param {string} mood - The mood to apply
     */
    function moveGhost(ghostContainer, mood) {
      // For "other" moods, randomly assign movement from existing moods
      const actualMood = mood === 'other' ? getRandomMood() : mood;
      
      // Mood-specific floating parameters
      let floatRangeX, floatRangeY, floatSpeed;
      
      switch(actualMood) {
        case 'joy':
          floatRangeX = 1 + Math.random() * 0.5;
          floatRangeY = 1 + Math.random() * 0.5;
          floatSpeed = 0.01 + Math.random() * 0.005;
          break;
        case 'sadness':
          floatRangeX = 0.5 + Math.random() * 0.3;
          floatRangeY = 0.8 + Math.random() * 0.4;
          floatSpeed = 0.008 + Math.random() * 0.004;
          break;
        case 'anger':
          floatRangeX = 1.5 + Math.random() * 0.8;
          floatRangeY = 1 + Math.random() * 0.5;
          floatSpeed = 0.015 + Math.random() * 0.008;
          break;
        case 'fear':
          floatRangeX = 2 + Math.random() * 1;
          floatRangeY = 1.5 + Math.random() * 0.8;
          floatSpeed = 0.02 + Math.random() * 0.01;
          break;
        case 'disgust':
          floatRangeX = 0.5 + Math.random() * 0.3;
          floatRangeY = 0.5 + Math.random() * 0.3;
          floatSpeed = 0.01 + Math.random() * 0.005;
          break;
        case 'inlove':
          floatRangeX = 0.8 + Math.random() * 0.4;
          floatRangeY = 1.2 + Math.random() * 0.6;
          floatSpeed = 0.015 + Math.random() * 0.007;
          break;
        default:
          floatRangeX = 1 + Math.random() * 0.5;
          floatRangeY = 1 + Math.random() * 0.5;
          floatSpeed = 0.01 + Math.random() * 0.005;
      }
      
      let angle = Math.random() * Math.PI * 2;
      let xDirection = Math.random() > 0.5 ? 1 : -1;
      let yDirection = Math.random() > 0.5 ? 1 : -1;
      
      // Add more random directional changes
      let directionChangeCounter = 0;
      const directionChangeFrequency = 50 + Math.floor(Math.random() * 100);
      
      function animate() {
        if (!document.body.contains(ghostContainer)) return;
        
        // Occasionally change direction randomly
        directionChangeCounter++;
        if (directionChangeCounter > directionChangeFrequency) {
          if (Math.random() > 0.7) xDirection *= -1;
          if (Math.random() > 0.7) yDirection *= -1;
          directionChangeCounter = 0;
        }
        
        // Calculate floating movement
        const floatX = Math.sin(angle) * floatRangeX * xDirection;
        const floatY = Math.cos(angle * 0.7) * floatRangeY * yDirection;
        
        // Apply floating to position
        const currentX = parseFloat(ghostContainer.style.left || 0);
        const currentY = parseFloat(ghostContainer.style.top || 0);
        
        const newX = currentX + floatX;
        const newY = currentY + floatY;
        
        // Keep within bounds with gentle bouncing and change direction when hitting edges
        let boundedX = newX;
        let boundedY = newY;
        
        if (newX > window.innerWidth - 100) {
          boundedX = window.innerWidth - 100;
          xDirection = -1;
        }
        if (newX < 0) {
          boundedX = 0;
          xDirection = 1;
        }
        if (newY > window.innerHeight - 150) {
          boundedY = window.innerHeight - 150;
          yDirection = -1;
        }
        if (newY < 0) {
          boundedY = 0;
          yDirection = 1;
        }
        
        ghostContainer.style.left = boundedX + 'px';
        ghostContainer.style.top = boundedY + 'px';
        
        // Update stored position
        const ghostId = ghostContainer.dataset.ghostId;
        if (ghostId && ghostPositions.has(ghostId)) {
          ghostPositions.set(ghostId, { x: boundedX, y: boundedY });
        }
        
        angle += floatSpeed;
        requestAnimationFrame(animate);
      }
      
      animate();
    }

    // ==================== BLOG OVERLAY ====================
    
    /**
     * Shows the blog view for a thought
     * @param {Object} thought - The thought to display
     */
    function showBlogView(thought) {
      // Set blog content
      blogGhost.className = `blog-ghost ${thought.mood}`;
      
      // Set mood-specific properties for blog ghost
      setMoodProperties(blogGhost, thought.mood);
      
      // Display custom mood name if it's an "other" mood
      let moodDisplay = thought.mood;
      if (thought.mood === 'other') {
        if (thought.customMood && thought.customMood.name) {
          moodDisplay = thought.customMood.name;
        } else {
          moodDisplay = "Mystery Mood";
        }
      }
      
      // Add emoji if available
      let emojiDisplay = "";
      if (thought.mood === 'other' && thought.customMood && thought.customMood.emoji) {
        emojiDisplay = " " + thought.customMood.emoji;
      }
      
      blogMood.textContent = `${moodDisplay.toUpperCase()}${emojiDisplay}`;
      blogDate.textContent = thought.date;
      blogTitle.textContent = thought.title || "Untitled Thought";
      blogText.textContent = thought.text;
      
      // Display HTML content if available
      if (thought.htmlContent) {
        blogHtml.innerHTML = thought.htmlContent;
        blogHtml.style.display = 'block';
      } else {
        blogHtml.style.display = 'none';
      }
      
      // Show the overlay
      blogOverlay.classList.add('active');
    }

    // ==================== INITIALIZATION ====================
    
    // Load ghosts and set up real-time subscription when page loads
    window.addEventListener('load', () => {
      loadGhosts();
      setupRealtimeSubscription();
    });
  </script>
</body>
</html>